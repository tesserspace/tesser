---
title: Live Trading
description: Deploy strategies with the same binaries you backtest.
---

## Checklist

- Configure API keys in `config/{env}.toml`.
- Set `execution.target = "bybit"` (or your custom connector).
- Point `data.market_stream` to the production WebSocket endpoint.

## Launch

```bash
cargo run -p tesser-cli -- \
    live run \
    --strategy-config strategies/sma_cross.toml \
    --env prod
```

The CLI spins up three async tasks:

1. **Market Data** – Streams ticks into the event bus.
2. **Strategy Runtime** – Executes your WASM-free Rust strategies with millisecond latency.
3. **Execution Engine** – Routes intent to the exchange and persists state for recovery.

If the process restarts it reloads everything from the SQLite snapshot and resumes from the latest offsets. Pair it with Prometheus exporters to watch latency, error rates, and per-strategy PnL in Grafana.

## Real-Time Monitoring (Commander TUI)

Run the monitor sub-command from another terminal to connect to the live control plane and inspect everything without digging through log files:

```bash
cargo run -p tesser-cli -- \
    --env default \
    monitor \
    --control-addr 127.0.0.1:50051
```

What you get:

- **Status header** showing equity, realized PnL, last data timestamp, and whether Liquidate-Only is active.
- **Positions / Active Orders** tables that stream updates over gRPC so you instantly see fills and algo progress.
- **Live Log** that color-codes Signals, Order events, and Fills, keeping the event bus visible while the runtime stays headless.
- **Help & Shortcuts** footer explaining the available key bindings so on-call operators know what to do at a glance.

Press `m` to open the command palette and then `c` to initiate a “Cancel All” panic action. For safety, you must type `cancel all` and hit `Enter` to confirm before the CLI contacts the control plane, making it much harder to fat-finger destructive operations.

## Connector Rate Limits

Bybit and Binance connectors now enforce client-side throttling. Configure them per exchange entry in `config/{env}.toml`:

```toml
[exchange.prod]
driver = "bybit"
rest_url = "https://api.bybit.com"
ws_url = "wss://stream.bybit.com"
api_key = "..."
api_secret = "..."

[exchange.prod.params]
rate_limit_tier = "vip"      # or override with `private_rps = 30`
public_rps = 100               # optional, defaults to 50

[exchange.prod_binance]
driver = "binance"
rest_url = "https://fapi.binance.com"
ws_url = "wss://fstream.binance.com/stream"
api_key = "..."
api_secret = "..."

[exchange.prod_binance.params]
weight_limit_per_minute = 600  # default is 1200, lower it for testing
```

Each connector now waits for the appropriate token bucket before issuing HTTP calls, shielding your API keys from accidental bans while still allowing you to dial in higher tiers as your VIP level increases.

## Flight Recorder

Set `--record-data <path>` when you launch `tesser-cli live run` to stream every `Tick`, `Candle`, `Fill`, and order update into partitioned Parquet files. The recorder runs on its own Tokio task, buffers data in Arrow `RecordBatch`es, and rotates files per day under the provided directory (defaults to `data/flight_recorder`).

```bash
cargo run -p tesser-cli -- \
    live run \
    --record-data data/flight_recorder \
    --strategy-config strategies/sma_cross.toml
```

You can sanity check any file without leaving the CLI by using the new inspector:

```bash
cargo run -p tesser-cli -- \
    data inspect-parquet data/flight_recorder/ticks/2025-05-01/ticks-*.parquet \
    --rows 10
```

The output is Arrow's pretty table format, which makes it easy to spot malformed symbols, timestamps, or prices before feeding the data into Pandas/Polars for Phase 2 workflows.

## Order Book Integrity Monitoring

Microstructure strategies (scalpers, peggers, etc.) are only as good as the order book they see. The Bybit and Binance connectors now publish the exchange-provided checksum alongside the locally reconstructed CRC32 so that the runtime can detect silent desyncs:

- `tesser_order_book_checksum_mismatches_total{driver,symbol}` (Prometheus) increments any time the local checksum diverges from what the exchange reports. Wire this into Grafana/Alertmanager to catch data drift before fills look “off”.
- The live CLI also emits an `Order book checksum mismatch` webhook/alert with the driver, symbol, and both checksums. This reuses the existing alerting config, so no extra setup is required.

If you see repeated mismatches for a symbol, the runtime will already be attempting to resubscribe, but you should still investigate packet loss, fan-out latency, or upstream throttling that may point to a deeper connectivity problem.
